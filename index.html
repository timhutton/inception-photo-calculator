<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Inception Generator</title>
</head>
<body>

<canvas id="myCanvas" width="900" height="900">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>

function add(a,b) {
    return { x:a.x+b.x, y:a.y+b.y };
}

function sub(a,b) {
    return { x:a.x-b.x, y:a.y-b.y };
}

function mul(p,f) {
    return { x:p.x*f, y:p.y*f };
}

function dot(a,b) {
    return a.x*b.x + a.y*b.y;
}

function norm(a) {
    return Math.sqrt(a.x*a.x + a.y*a.y);
}

function angle(a,b) {
    return Math.acos( dot(a,b) / ( norm(a) * norm(b) ) );
}

function lerp(a,b,t) {
    return add(mul(a,1-t),mul(b,t));
}

function rot90(v) {
    return { x:-v.y, y:-x };
}

function getBezierPoint(pts,t) {
    if(pts.length==1) {
        return pts[0];
    }
    var new_pts = [];
    for(var i=0;i<pts.length-1;i++) {
        new_pts.push(lerp(pts[i],pts[i+1],t));
    }
    return getBezierPoint(new_pts,t);
}

function drawBezier(pts) {
    // draw the control mesh
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    for(var i=1;i<npts;i++) {
        ctx.lineTo(pts[i].x,pts[i].y);
    }
    ctx.stroke();

    // draw the curve
    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    for(var t=0;t<1;t+=0.001) {
        var p = getBezierPoint(pts,t);
        ctx.lineTo(p.x,p.y);
    }
    ctx.lineTo(pts[npts-1].x,pts[npts-1].y);
    ctx.stroke();

    // draw the waypoints
    for(var i=0;i<npts;i++) {
        var t = i / (npts-1);
        drawDot(getBezierPoint(pts,t));
    }
}

function lineWithLineIntersection( u0, v0, u1, v1 ) {
    // http://stackoverflow.com/a/4977569/126823
    var x00 = u0.x;
    var y00 = u0.y;
    var x10 = u1.x;
    var y10 = u1.y;
    var x01 = v0.x;
    var y01 = v0.y;
    var x11 = v1.x;
    var y11 = v1.y;
    var det = x11 * y01 - x01 * y11;
    if( Math.abs( det ) < epsilon ) {
        return { test:false }; // lines parallel or colinear
    }
    var t = -(-(x00-x10)*y11 + (y00-y10)*x11 ) / det;    // ip = u0 + t*v0
    var s =  ( (x00-x10)*y01 - (y00-y10)*x01 ) / det;    // ip = u1 + s*v1
    return { test:true, u1:t, u2:s };
}

function lineSegmentsIntersection(s1,s2) {
    var cr = lineWithLineIntersection( s1.p1, sub( s1.p2, s1.p1 ), s2.p1, sub( s2.p2, s2.p1 ) );
    if( !cr.test || cr.u1 < -epsilon || cr.u1 > 1+epsilon || cr.u2 < -epsilon || cr.u2 > 1+epsilon ) return { test:false };
    var p = lerp( s1.p1, s1.p2, cr.u1 );
    return { test:true, point:p, u1:cr.u1, u2:cr.u2 };
}

function intersectBezier(pts,a,b) {
    // test each line segment in the curve, keep the intersection nearest a
    var ray = { p1:a, p2:b };
    var c = pts[0];
    var d = c;
    var inc = 0.01;
    for(var t=inc;t<1;t+=inc) {
        d = getBezierPoint(pts,t);
        var line = { p1:c, p2:d };
        var result = lineSegmentsIntersection(ray, line);
        if( result.test ) {
            result.segment = line;
            result.t = t + result.u2*inc;
            result.theta = angle(sub(ray.p2,ray.p1),sub(line.p2,line.p1));
            result.d = norm(sub(a,result.point));
            return result;
        }
        c = d;
    }
    return { test: false };
}

function drawBaseCamera(c) {
    drawCameraBody(c);

    // rays
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    var nr = 10;
    for(var i=0;i<nr;i++) {
        var h = i * c.hh * 2 / (nr-1) - c.hh;
        var p = add(c,mul(sub(mul(c.vx,c.f),mul(c.vy,h)),100));
        var result = intersectBezier(pts,c,p);
        var ip = {};
        if( result.test ) {
            ip = getBezierPoint(pts,result.t);//result.point;
            // DEBUG:
            var bp = getBezierPoint(base_pts,result.t);
            ctx.moveTo(c.x,c.y);
            ctx.lineTo(bp.x,bp.y);
        } else {
            ip = p;
        }
        ctx.moveTo(c.x,c.y);
        ctx.lineTo(ip.x,ip.y);
    }
    ctx.stroke();
}

function drawCameraBody(c) {
    // camera body: triangle
    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.moveTo(c.x,c.y);
    var p1 = add(add(c,mul(c.vx,c.f)),mul(c.vy,c.hh));
    var p2 = sub(add(c,mul(c.vx,c.f)),mul(c.vy,c.hh));
    ctx.lineTo(p1.x,p1.y);
    ctx.lineTo(p2.x,p2.y);
    ctx.lineTo(c.x,c.y);
    ctx.stroke();
    drawDot(c);
}

function drawDot(p) {
    ctx.fillStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.ellipse(p.x,p.y,dot_radius,dot_radius,0,0,Math.PI*2);
    ctx.fill();
}

function drawHandle(p) {
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.rect(p.x-handle_radius,p.y-handle_radius,handle_radius*2,handle_radius*2);
    ctx.stroke();
}

function draw() {

    // bounding rect
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.rect(0,0,800,600);
    ctx.stroke();

    // draw the distorted landcape
    drawBezier(pts);
    for(var i = 0; i < npts; ++i) {
        drawHandle( pts[i] );
    }

    // draw the base landscape
    drawBezier(base_pts);

    // draw the camera and rays
    drawBaseCamera(camera);

    // draw caption
    ctx.font="18px Verdana";
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillText("Drag the handles to change the landscape", 10, 620);
}

var ctx = document.getElementById("myCanvas").getContext("2d");
var npts = 8;
var pts = [];
var base_pts = [];
for(var i=0;i<npts;i++) {
    pts.push(      { x:50+i*700/(npts-1), y:300 } );
    base_pts.push( { x:50+i*700/(npts-1), y:500 } );
}
pts[0] = { x:50, y:50 };
var dot_radius = 2;
var handle_radius = 6;
var camera = { x:645, y:250, vx:{x:-1,y:0}, vy:{x:0,y:1}, f:45, hh:15 };
var epsilon = 1E-6;
draw();

</script>

</body>
</html>
