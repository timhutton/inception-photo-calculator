<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Inception Generator</title>
</head>
<body>

<canvas id="myCanvas" width="900" height="900">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>

function lerp(a,b,t) {
    return [a[0]*(1-t)+b[0]*t,a[1]*(1-t)+b[1]*t];
}

function getBezierPoint(pts,t) {
    if(pts.length==1) {
        return pts[0];
    }
    var new_pts = [];
    for(var i=0;i<pts.length-1;i++) {
        new_pts.push(lerp(pts[i],pts[i+1],t));
    }
    return getBezierPoint(new_pts,t);
}

function drawBezier(pts) {
    // draw the control mesh
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(var i=1;i<npts;i++) {
        ctx.lineTo(pts[i][0],pts[i][1]);
    }
    ctx.stroke();

    // draw the curve
    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(var t=0;t<1;t+=0.001) {
        var p = getBezierPoint(pts,t);
        ctx.lineTo(p[0],p[1]);
    }
    ctx.lineTo(pts[npts-1][0],pts[npts-1][1]);
    ctx.stroke();

    // draw the waypoints
    for(var i=0;i<npts;i++) {
        var t = i / (npts-1);
        drawDot(getBezierPoint(pts,t));
    }
}

function doLineSegmentsIntersect(a,b,c,d) {
    // TODO
}

function length2(a,b) {
    return (a[0]-b[0])**2 + (a[1]-b[1])**2;
}

function intersectBezier(pts,a,b) {
    // test each line segment in the curve, keep the intersection nearest a
    // TODO
    return b;
    /*ctx.moveTo(pts[0][0],pts[0][1]);
    for(var t=0;t<1;t+=0.001) {
        var p = getBezierPoint(pts,t);
        ctx.lineTo(p[0],p[1]);
    }
    ctx.lineTo(pts[npts-1][0],pts[npts-1][1]);*/
}

function drawCameraBody(c) {
    // camera body: triangle
    ctx.strokeStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.moveTo(c.x,c.y);
    ctx.lineTo(c.x + c.vx[0]*c.f + c.vy[0]*c.hh,
               c.y + c.vx[1]*c.f + c.vy[1]*c.hh);
    ctx.lineTo(c.x + c.vx[0]*c.f - c.vy[0]*c.hh,
               c.y + c.vx[1]*c.f - c.vy[1]*c.hh);
    ctx.lineTo(c.x,c.y);
    ctx.stroke();
    drawDot([c.x,c.y]);
}

function drawCamera(c) {
    drawCameraBody(c);

    // rays
    var cp = [c.x,c.y];
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    var nr = 10;
    for(var i=0;i<nr;i++) {
        var h = i * c.hh * 2 / (nr-1) - c.hh;
        var p = [c.x + 100*(c.vx[0]*c.f - c.vy[0]*h),
                 c.y + 100*(c.vx[1]*c.f - c.vy[1]*h)];
        var ip = intersectBezier(pts,cp,p);
        ctx.moveTo(c.x,c.y);
        ctx.lineTo(ip[0],ip[1]);
    }
    ctx.stroke();
}

function drawDot(p) {
    ctx.fillStyle = "rgba(0,0,0,0.9)";
    ctx.beginPath();
    ctx.ellipse(p[0],p[1],dot_radius,dot_radius,0,0,Math.PI*2);
    ctx.fill();
}

function drawHandle(p) {
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.rect(p[0]-handle_radius,p[1]-handle_radius,handle_radius*2,handle_radius*2);
    ctx.stroke();
}

function draw() {

    // bounding rect
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.rect(0,0,800,600);
    ctx.stroke();

    // draw the distorted landcape
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    for(var i = 0; i < npts; ++i) {
        var p = pts[i];
        ctx.rect(p[0]-handle_radius,p[1]-handle_radius,handle_radius*2,handle_radius*2);
    }
    ctx.stroke();
    drawBezier(pts);

    // draw the base landscape
    drawBezier(base_pts);

    // draw the camera and rays
    drawCamera(camera);

    // draw caption
    ctx.font="18px Verdana";
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillText("Drag the handles to change the landscape", 10, 620);
}

var ctx = document.getElementById("myCanvas").getContext("2d");
var npts = 8;
var base_pts = [];
var pts = [];
for(var i=0;i<npts;i++) {
    base_pts.push([50+i*700/(npts-1),500]);
    pts.push([50+i*700/(npts-1),300]);
}
pts[0] = [50,50];
var dot_radius = 2;
var handle_radius = 6;
// we define the camera on the distorted landscape
var camera = { x:750, y:250, vx:[-1,0], vy:[0,1], f:45, hh:20 };
draw();

</script>

</body>
</html>
